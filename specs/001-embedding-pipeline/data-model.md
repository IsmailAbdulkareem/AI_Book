# Data Model: Embedding Pipeline

**Feature**: 001-embedding-pipeline
**Date**: 2025-12-15

## Overview

This document defines the data structures used in the embedding pipeline. All structures are implemented as Python dataclasses in the single `main.py` file.

## Entities

### 1. SitemapEntry

Represents a URL discovered from the sitemap.

```python
@dataclass
class SitemapEntry:
    loc: str              # Full URL of the page
    lastmod: str | None   # Last modified date (ISO format)
    priority: float | None  # Sitemap priority (0.0-1.0)
```

**Source**: Parsed from sitemap.xml
**Used By**: `get_all_urls()` function

---

### 2. PageContent

Represents extracted content from a single documentation page.

```python
@dataclass
class PageContent:
    url: str           # Source URL
    title: str         # Page title (from <h1> or <title>)
    content: str       # Cleaned text content
    headings: list[str]  # List of section headings
```

**Source**: Extracted by `extract_text_from_url()` function
**Validation Rules**:
- `url` must be non-empty
- `content` must have minimum 100 characters
- Empty pages are skipped

---

### 3. Chunk

Represents a segment of content suitable for embedding.

```python
@dataclass
class Chunk:
    text: str           # Chunk text content
    url: str            # Source page URL
    title: str          # Source page title
    chunk_index: int    # Position in source document (0-indexed)
    total_chunks: int   # Total chunks from this document
```

**Source**: Generated by `chunk_text()` function
**Validation Rules**:
- `text` length: 100-1500 characters
- `chunk_index` >= 0
- `chunk_index` < `total_chunks`

**Chunking Parameters**:
| Parameter | Value | Rationale |
|-----------|-------|-----------|
| chunk_size | 1500 | Fits within Cohere's 512 token limit |
| overlap | 200 | Preserves context across boundaries |
| min_chunk | 100 | Avoids embedding noise |

---

### 4. EmbeddedChunk

Represents a chunk with its vector embedding, ready for storage.

```python
@dataclass
class EmbeddedChunk:
    chunk: Chunk                # Original chunk data
    embedding: list[float]      # 1024-dimensional vector
```

**Source**: Generated by `embed()` function
**Validation Rules**:
- `embedding` must have exactly 1024 dimensions
- All values must be floats

---

## Qdrant Point Structure

When stored in Qdrant, each chunk becomes a point with:

```python
PointStruct(
    id=uuid,  # Auto-generated unique ID
    vector=embedding,  # 1024-dim float list
    payload={
        "url": str,           # Source page URL
        "title": str,         # Page title
        "text": str,          # Chunk text content
        "chunk_index": int,   # Position in document
        "total_chunks": int,  # Total chunks from document
        "ingested_at": str,   # ISO timestamp
    }
)
```

**Collection Name**: `AI-Book`

**Collection Configuration**:
```python
VectorParams(
    size=1024,              # Cohere embed-english-v3.0 dimensions
    distance=Distance.COSINE  # Similarity metric
)
```

---

## Data Flow

```
sitemap.xml
    │
    ▼
┌─────────────────┐
│  SitemapEntry   │  get_all_urls()
│  (url, lastmod) │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│   PageContent   │  extract_text_from_url()
│ (url, title,    │
│  content)       │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│     Chunk       │  chunk_text()
│ (text, url,     │
│  title, index)  │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  EmbeddedChunk  │  embed()
│ (chunk,         │
│  embedding)     │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  Qdrant Point   │  save_chunk_to_qdrant()
│ (id, vector,    │
│  payload)       │
└─────────────────┘
```

---

## Metadata Schema

All Qdrant points include these payload fields:

| Field | Type | Description | Filterable |
|-------|------|-------------|------------|
| url | string | Source page URL | Yes |
| title | string | Page title | Yes |
| text | string | Chunk content | No (full-text) |
| chunk_index | integer | Position in document | Yes |
| total_chunks | integer | Total chunks from document | No |
| ingested_at | string | ISO timestamp | Yes |

**Example Query Filter**:
```python
# Find chunks from a specific module
filter = Filter(
    must=[
        FieldCondition(
            key="url",
            match=MatchText(text="/module-1/")
        )
    ]
)
```
